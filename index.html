<!-- Start with everything in html file for now, move each segment out as they grow -->

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Math 7 - Linear Algebra: Honors Project</title>

  <style>
    .matrix_wrapper {
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 32px;
      margin-top: 16px;
      margin-bottom: 16px;
    }
    table {
      border: 1px solid black;
      margin-left: 8px;
      margin-right: 8px;
    }
    td {
      text-align: center;
      width: 48px;
      height: 48px;
      padding: 4px;
    }
  </style>
</head>

<body>
  <script>  
    const matrices = [
      {
        name: 'A',
        values: [
          [1, 0, -3, -2],
          [3, 1, -2, 5],
          [2, 2, 1, 4]
        ],
        steps: ''
      },
      {
        name: 'B',
        values: [
          [1, 1, 1, 500000],
          [3/100, 4/100, 5/100, 20500],
          [-5/2, 1, 0, 0]
        ],
        steps: ''
      },
      {
        name: 'C',
        values: [
          [0, 0, 2, -2],
          [0, 1, -7, 3],
          [5, 0, 4, 0]
        ],
        steps: ''
      },
      {
        name: 'D',
        values: [
          [0, 2, 4, 4, -8],
          [2, 4, -3, -5, 4],
          [5, 0, 1, -3, -4],
          [1, 1, 0, 1, 5]
        ],
        steps: ''
      },
      {
        name: 'E',
        values: [
          [2, 0, 7],
          [3, 4, 4],
          [0, 1, 0]
        ],
        steps: ''
      }
    ];

    function loadMatrix(matrix) {
      // rounded_matrix = roundMatrix(matrix.values, 4);
      const matrix_wrapper = document.createElement('div');
      matrix_wrapper.classList.add('matrix_wrapper');
      const matrix_title = document.createElement('div');
      matrix_title.innerHTML = 'Matrix ' + matrix.name;
      matrix_wrapper.appendChild(matrix_title);
      
      const matrix_table = document.createElement('table');
      matrix.values.forEach(row => {
        const tr = document.createElement('tr');
        row.forEach(element => {
          const td = document.createElement('td');
          td.innerHTML = element;
          tr.appendChild(td);
        })
        matrix_table.appendChild(tr);
      })
      matrix_wrapper.appendChild(matrix_table);

      if (matrix.steps) {
        const matrix_step = document.createElement('div');
        matrix_step.innerHTML = matrix.steps;
        matrix_wrapper.appendChild(matrix_step);
      }

      document.body.appendChild(matrix_wrapper);      
    }

    function gaussJordan(matrix) {
      rrefMatrix = { ...matrix };

      // Move to the first column that isn't full of zeros
      // checkForZeroColumn(matrix);

      // Swap rows if needed so that the top row has the leading number
      for (i = 0; i < rrefMatrix.values.length; i++) {
        if (rrefMatrix.values[0][0] === 0 && rrefMatrix.values[i][0] !== 0) {
          swapRow(rrefMatrix.values[0], rrefMatrix.values[i]);
        }
      }

      for (a = 0; a < rrefMatrix.values.length; a++) {
        // Convert all values below the leading coefficient of row a to zero
        for (i = a + 1; i < rrefMatrix.values.length; i++) {
          if (rrefMatrix.values[i][a] !== 0) {
            canceling_coefficient = -1 * rrefMatrix.values[i][a]/rrefMatrix.values[a][a]
            addRow(rrefMatrix.values[i], rrefMatrix.values[a], canceling_coefficient);
            rrefMatrix.steps += '<br>R' + (i + 1) + ' + (' + canceling_coefficient + ')*R' + (a + 1) + ' → R' + (i + 1);
          }
        }
        rrefMatrix.name += '\'';
        loadMatrix(rrefMatrix);

        // Convert all values above the leading coefficient of row a to zero
        for (i = a - 1; i >= 0; i--) {
          if (rrefMatrix.values[i][a] !== 0) {
            canceling_coefficient = -1 * rrefMatrix.values[i][a]/rrefMatrix.values[a][a]
            addRow(rrefMatrix.values[i], rrefMatrix.values[a], canceling_coefficient);
            rrefMatrix.steps += '<br>R' + (i + 1) + ' + (' + canceling_coefficient + ')*R' + (a + 1) + ' → R' + (i + 1);
          }
        }
        rrefMatrix.name += '\'';
        loadMatrix(rrefMatrix);
      }
      
      // Scale all leading coefficients to 1
      for (i = 0; i < rrefMatrix.values.length; i++) {
        scaleRow(rrefMatrix.values[i], (1 / rrefMatrix.values[i][i]));
        rrefMatrix.steps += '<br>(' + canceling_coefficient + ')*R' + (i + 1) + ' → R' + (i + 1);
      }
      
      rrefMatrix.name += '\'';
      loadMatrix(rrefMatrix);
    }

    /**
     * Swaps two rows in a 2D array (matrix)
     * 
     * @param {Array<number>} row1 - The index of the first row to swap.
     * @param {Array<number>} row2 - The index of the second row to swap.
     */
    function swapRow(row_A, row_B) {
      let temp = row_A.slice();
      row_A.forEach((element, index) => {
        row_A[index] = row_B[index];
      });
      row_B.forEach((element, index) => {
        row_B[index] = temp[index];
      });
    }

    /**
     * Swaps two rows in a 2D array (matrix)
     * 
     * @param {Array<number>} row1 - The index of the row to be multiplied.
     * @param {number} coefficient - Coefficient to multiply to row.
     */
    function scaleRow(row, coefficient) {
      row.forEach((element, index) => {
        row[index] *= coefficient;
      });
    }

    /**
     * Adds two rows in a 2D array (matrix)
     * 
     * @param {Array<number>} row1 - Row to be added to.
     * @param {Array<number>} row2 - Addend to row1.
     * @param {number} coefficient - Coefficient to multiply to row2 before adding.
     */
    function addRow(row_A, row_B, coefficient = 1) {
      row_A.forEach((element, index) => {
        row_A[index] += (coefficient * row_B[index]);
      })
    }

    /**
     * Forces iteration to begin from the next column if the first matrix column are all zeros
     */
    function checkForZeroColumn(matrix) {
      return true;
    }

    function roundMatrix(matrix, digits) {
      rounded_matrix = matrix;
      let round = Math.pow(10, digits);
      rounded_matrix.forEach(row => {
        row.forEach((element, index) => {
          row[index] = Math.round(row[index]*round)/round;
        })
      });
      return rounded_matrix;
    }

    loadMatrix(matrices[0]);
    gaussJordan(matrices[0]);
  </script>
</body>
</html>